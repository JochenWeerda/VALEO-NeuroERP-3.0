"""
ISO 27001 Vulnerability Management System
Informationssicherheits-Managementsystem Vulnerability Management

Dieses Modul implementiert das Vulnerability Management gemäß ISO 27001 Annex A.12.6.1
für VALEO-NeuroERP mit automatischer Schwachstellensuche, -bewertung und -behebung.
"""

from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum
import logging
import uuid
import json

logger = logging.getLogger(__name__)


class VulnerabilitySeverity(Enum):
    """CVSS-based severity levels"""
    NONE = "NONE"
    LOW = "LOW"
    MEDIUM = "MEDIUM"
    HIGH = "HIGH"
    CRITICAL = "CRITICAL"


class VulnerabilityStatus(Enum):
    """Vulnerability lifecycle status"""
    DETECTED = "DETECTED"
    CONFIRMED = "CONFIRMED"
    ASSIGNED = "ASSIGNED"
    IN_PROGRESS = "IN_PROGRESS"
    MITIGATED = "MITIGATED"
    RESOLVED = "RESOLVED"
    ACCEPTED_RISK = "ACCEPTED_RISK"
    FALSE_POSITIVE = "FALSE_POSITIVE"


class ScanType(Enum):
    """Types of vulnerability scans"""
    NETWORK_SCAN = "network_scan"
    WEB_APPLICATION_SCAN = "web_application_scan"
    DATABASE_SCAN = "database_scan"
    CONTAINER_SCAN = "container_scan"
    CODE_SCAN = "code_scan"
    DEPENDENCY_SCAN = "dependency_scan"
    CONFIGURATION_SCAN = "configuration_scan"


@dataclass
class Vulnerability:
    """Vulnerability representation"""
    id: str
    cve_id: Optional[str]
    title: str
    description: str
    severity: VulnerabilitySeverity
    cvss_score: float
    affected_asset: str
    affected_component: str
    port_service: Optional[str]
    detection_date: datetime
    last_seen: datetime
    status: VulnerabilityStatus

    # Classification
    scan_type: ScanType
    category: str  # e.g., "Injection", "XSS", "Weak Crypto"
    cwe_id: Optional[str]

    # Impact assessment
    exploitability: str
    impact: str
    attack_vector: str

    # Remediation
    remediation_steps: List[str] = field(default_factory=list)
    remediation_effort: str = "medium"  # low, medium, high
    remediation_priority: int = 3  # 1=critical, 5=low

    # Tracking
    assigned_to: Optional[str] = None
    due_date: Optional[datetime] = None
    resolved_date: Optional[datetime] = None
    false_positive_reason: Optional[str] = None

    # Evidence
    evidence: Dict[str, Any] = field(default_factory=dict)
    references: List[str] = field(default_factory=list)

    # Metadata
    tenant_id: str = "system"
    created_at: datetime = field(default_factory=datetime.utcnow)
    updated_at: datetime = field(default_factory=datetime.utcnow)


@dataclass
class VulnerabilityScan:
    """Vulnerability scan representation"""
    id: str
    scan_type: ScanType
    target: str
    tenant_id: str
    started_at: datetime
    completed_at: Optional[datetime] = None
    status: str = "running"  # running, completed, failed
    scanner_version: str = ""
    findings_count: int = 0
    critical_findings: int = 0
    high_findings: int = 0
    medium_findings: int = 0
    low_findings: int = 0
    scan_duration: Optional[int] = None  # seconds
    scan_config: Dict[str, Any] = field(default_factory=dict)


class ISO27001VulnerabilityManagement:
    """
    ISO 27001 Vulnerability Management System
    Implements Annex A.12.6.1 - Control of Technical Vulnerabilities
    """

    def __init__(self, db_session, scan_scheduler=None, notification_service=None):
        self.db = db_session
        self.scan_scheduler = scan_scheduler
        self.notification_service = notification_service

        # Vulnerability tracking
        self.active_vulnerabilities: Dict[str, Vulnerability] = {}
        self.vulnerability_history: List[Vulnerability] = []

        # Scan configurations
        self.scan_configs = self._initialize_scan_configs()

        # SLA definitions (ISO 27001 requirements)
        self.sla_targets = {
            VulnerabilitySeverity.CRITICAL: timedelta(days=7),
            VulnerabilitySeverity.HIGH: timedelta(days=30),
            VulnerabilitySeverity.MEDIUM: timedelta(days=90),
            VulnerabilitySeverity.LOW: timedelta(days=180)
        }

        # Risk thresholds
        self.risk_thresholds = {
            'max_critical_open': 0,  # Zero tolerance for critical vulns
            'max_high_open': 5,
            'max_medium_open': 20,
            'scan_frequency_days': 7
        }

    def _initialize_scan_configs(self) -> Dict[ScanType, Dict[str, Any]]:
        """Initialize scan configurations for different scan types"""
        return {
            ScanType.NETWORK_SCAN: {
                'enabled': True,
                'frequency': 'weekly',
                'scanner': 'nessus',
                'scope': 'all_network_assets',
                'ports': '1-65535',
                'timing': 'off_hours'
            },
            ScanType.WEB_APPLICATION_SCAN: {
                'enabled': True,
                'frequency': 'bi_weekly',
                'scanner': 'owasp_zap',
                'scope': 'web_applications',
                'depth': 'comprehensive',
                'auth_required': True
            },
            ScanType.DATABASE_SCAN: {
                'enabled': True,
                'frequency': 'weekly',
                'scanner': 'qualys_db',
                'scope': 'all_databases',
                'check_configs': True,
                'check_permissions': True
            },
            ScanType.CONTAINER_SCAN: {
                'enabled': True,
                'frequency': 'daily',
                'scanner': 'trivy',
                'scope': 'all_containers',
                'registries': ['dockerhub', 'ecr', 'acr']
            },
            ScanType.CODE_SCAN: {
                'enabled': True,
                'frequency': 'on_commit',
                'scanner': 'sonarcloud',
                'scope': 'application_code',
                'languages': ['python', 'typescript', 'javascript']
            },
            ScanType.DEPENDENCY_SCAN: {
                'enabled': True,
                'frequency': 'daily',
                'scanner': 'dependabot',
                'scope': 'package_dependencies',
                'ecosystems': ['npm', 'pypi', 'maven']
            },
            ScanType.CONFIGURATION_SCAN: {
                'enabled': True,
                'frequency': 'weekly',
                'scanner': 'lynis',
                'scope': 'system_configurations',
                'standards': ['cis', 'iso27001']
            }
        }

    def start_vulnerability_scan(self, scan_type: ScanType, target: str,
                               tenant_id: str = "system") -> str:
        """
        Start a vulnerability scan
        Returns scan ID
        """
        scan_id = str(uuid.uuid4())

        scan = VulnerabilityScan(
            id=scan_id,
            scan_type=scan_type,
            target=target,
            tenant_id=tenant_id,
            started_at=datetime.utcnow(),
            scan_config=self.scan_configs.get(scan_type, {})
        )

        # In production, this would trigger actual scanning
        logger.info(f"Started vulnerability scan: {scan_id} ({scan_type.value}) for target: {target}")

        # For demo purposes, simulate scan completion
        self._simulate_scan_completion(scan)

        return scan_id

    def _simulate_scan_completion(self, scan: VulnerabilityScan):
        """Simulate scan completion with mock vulnerabilities"""
        # Simulate some processing time
        import time
        time.sleep(0.1)

        # Generate mock findings based on scan type
        mock_findings = self._generate_mock_findings(scan)

        scan.completed_at = datetime.utcnow()
        scan.status = "completed"
        scan.findings_count = len(mock_findings)
        scan.scan_duration = 300  # 5 minutes

        # Count by severity
        for finding in mock_findings:
            severity = finding['severity']
            if severity == 'CRITICAL':
                scan.critical_findings += 1
            elif severity == 'HIGH':
                scan.high_findings += 1
            elif severity == 'MEDIUM':
                scan.medium_findings += 1
            else:
                scan.low_findings += 1

        # Process findings
        for finding in mock_findings:
            vuln_id = self._create_vulnerability_from_finding(finding, scan)
            logger.info(f"Created vulnerability: {vuln_id}")

    def _generate_mock_findings(self, scan: VulnerabilityScan) -> List[Dict[str, Any]]:
        """Generate mock findings for demonstration"""
        findings = []

        if scan.scan_type == ScanType.NETWORK_SCAN:
            findings = [
                {
                    'cve_id': 'CVE-2023-12345',
                    'title': 'OpenSSH Weak Cipher Suite',
                    'severity': 'HIGH',
                    'cvss_score': 7.5,
                    'category': 'Weak Cryptography',
                    'remediation': ['Update OpenSSH configuration', 'Disable weak ciphers']
                },
                {
                    'cve_id': None,
                    'title': 'Unnecessary Service Running',
                    'severity': 'MEDIUM',
                    'cvss_score': 4.2,
                    'category': 'Service Misconfiguration',
                    'remediation': ['Disable unnecessary services', 'Implement service hardening']
                }
            ]
        elif scan.scan_type == ScanType.WEB_APPLICATION_SCAN:
            findings = [
                {
                    'cve_id': 'CVE-2023-23456',
                    'title': 'SQL Injection Vulnerability',
                    'severity': 'CRITICAL',
                    'cvss_score': 9.1,
                    'category': 'Injection',
                    'remediation': ['Implement prepared statements', 'Input validation', 'WAF rules']
                }
            ]
        elif scan.scan_type == ScanType.CONTAINER_SCAN:
            findings = [
                {
                    'cve_id': 'CVE-2023-34567',
                    'title': 'Outdated Base Image',
                    'severity': 'MEDIUM',
                    'cvss_score': 5.3,
                    'category': 'Dependency Vulnerability',
                    'remediation': ['Update base image', 'Regular image scanning']
                }
            ]

        return findings

    def _create_vulnerability_from_finding(self, finding: Dict[str, Any], scan: VulnerabilityScan) -> str:
        """Create vulnerability from scan finding"""
        vuln_id = str(uuid.uuid4())

        vulnerability = Vulnerability(
            id=vuln_id,
            cve_id=finding.get('cve_id'),
            title=finding['title'],
            description=f"Finding from {scan.scan_type.value} scan",
            severity=VulnerabilitySeverity[finding['severity']],
            cvss_score=finding['cvss_score'],
            affected_asset=scan.target,
            affected_component=finding.get('component', 'unknown'),
            detection_date=scan.completed_at,
            last_seen=scan.completed_at,
            status=VulnerabilityStatus.DETECTED,
            scan_type=scan.scan_type,
            category=finding['category'],
            remediation_steps=finding['remediation'],
            tenant_id=scan.tenant_id
        )

        # Set due date based on SLA
        vulnerability.due_date = datetime.utcnow() + self.sla_targets[vulnerability.severity]

        # Calculate remediation priority
        vulnerability.remediation_priority = self._calculate_priority(vulnerability)

        self.active_vulnerabilities[vuln_id] = vulnerability

        return vuln_id

    def _calculate_priority(self, vulnerability: Vulnerability) -> int:
        """Calculate remediation priority (1=critical, 5=low)"""
        priority = 3  # Default medium

        # Adjust based on severity
        if vulnerability.severity == VulnerabilitySeverity.CRITICAL:
            priority = 1
        elif vulnerability.severity == VulnerabilitySeverity.HIGH:
            priority = 2
        elif vulnerability.severity == VulnerabilitySeverity.LOW:
            priority = 4

        # Adjust based on CVSS score
        if vulnerability.cvss_score >= 9.0:
            priority = max(priority - 1, 1)
        elif vulnerability.cvss_score >= 7.0:
            priority = min(priority + 1, 5)

        return priority

    def update_vulnerability_status(self, vuln_id: str, new_status: VulnerabilityStatus,
                                  update_data: Dict[str, Any] = None) -> bool:
        """
        Update vulnerability status and tracking information
        """
        if vuln_id not in self.active_vulnerabilities:
            return False

        vulnerability = self.active_vulnerabilities[vuln_id]
        old_status = vulnerability.status
        vulnerability.status = new_status
        vulnerability.updated_at = datetime.utcnow()

        # Status-specific updates
        if new_status == VulnerabilityStatus.RESOLVED:
            vulnerability.resolved_date = datetime.utcnow()
            # Move to history
            self.vulnerability_history.append(vulnerability)
            del self.active_vulnerabilities[vuln_id]
        elif new_status == VulnerabilityStatus.FALSE_POSITIVE:
            vulnerability.false_positive_reason = update_data.get('reason', 'Not specified')

        # Additional updates
        if update_data:
            for key, value in update_data.items():
                if hasattr(vulnerability, key):
                    setattr(vulnerability, key, value)

        logger.info(f"Vulnerability {vuln_id} status updated: {old_status.value} -> {new_status.value}")
        return True

    def get_vulnerability_report(self, vuln_id: str) -> Optional[Dict[str, Any]]:
        """Get detailed vulnerability report"""
        vuln = self.active_vulnerabilities.get(vuln_id)
        if not vuln:
            # Check history
            for hist_vuln in self.vulnerability_history:
                if hist_vuln.id == vuln_id:
                    vuln = hist_vuln
                    break

        if not vuln:
            return None

        # Calculate SLA compliance
        sla_compliant = True
        days_overdue = 0
        if vuln.due_date and vuln.status != VulnerabilityStatus.RESOLVED:
            if datetime.utcnow() > vuln.due_date:
                sla_compliant = False
                days_overdue = (datetime.utcnow() - vuln.due_date).days

        return {
            'id': vuln.id,
            'cve_id': vuln.cve_id,
            'title': vuln.title,
            'description': vuln.description,
            'severity': vuln.severity.value,
            'cvss_score': vuln.cvss_score,
            'category': vuln.category,
            'status': vuln.status.value,
            'affected_asset': vuln.affected_asset,
            'detection_date': vuln.detection_date.isoformat(),
            'due_date': vuln.due_date.isoformat() if vuln.due_date else None,
            'assigned_to': vuln.assigned_to,
            'remediation_steps': vuln.remediation_steps,
            'remediation_priority': vuln.remediation_priority,
            'sla_compliant': sla_compliant,
            'days_overdue': days_overdue,
            'references': vuln.references
        }

    def get_vulnerability_dashboard(self, tenant_id: str = "system") -> Dict[str, Any]:
        """Get vulnerability management dashboard"""
        # Filter vulnerabilities by tenant
        tenant_vulns = [
            vuln for vuln in self.active_vulnerabilities.values()
            if vuln.tenant_id == tenant_id
        ]

        # Calculate metrics
        severity_counts = {}
        status_counts = {}
        sla_compliance = {'compliant': 0, 'overdue': 0}

        for vuln in tenant_vulns:
            # Severity breakdown
            severity_counts[vuln.severity.value] = severity_counts.get(vuln.severity.value, 0) + 1

            # Status breakdown
            status_counts[vuln.status.value] = status_counts.get(vuln.status.value, 0) + 1

            # SLA compliance
            if vuln.due_date:
                if datetime.utcnow() > vuln.due_date:
                    sla_compliance['overdue'] += 1
                else:
                    sla_compliance['compliant'] += 1

        # Calculate risk score
        risk_score = self._calculate_risk_score(tenant_vulns)

        # Recent vulnerabilities
        recent_vulns = sorted(tenant_vulns, key=lambda x: x.detection_date, reverse=True)[:5]

        return {
            'total_vulnerabilities': len(tenant_vulns),
            'severity_breakdown': severity_counts,
            'status_breakdown': status_counts,
            'sla_compliance': sla_compliance,
            'risk_score': risk_score,
            'critical_vulnerabilities': severity_counts.get('CRITICAL', 0),
            'overdue_vulnerabilities': sla_compliance['overdue'],
            'recent_vulnerabilities': [
                {
                    'id': v.id,
                    'title': v.title,
                    'severity': v.severity.value,
                    'status': v.status.value,
                    'detection_date': v.detection_date.isoformat()
                } for v in recent_vulns
            ],
            'generated_at': datetime.utcnow().isoformat()
        }

    def _calculate_risk_score(self, vulnerabilities: List[Vulnerability]) -> int:
        """Calculate overall vulnerability risk score"""
        if not vulnerabilities:
            return 0

        total_score = 0
        for vuln in vulnerabilities:
            # Weight by severity and age
            severity_weight = {
                VulnerabilitySeverity.CRITICAL: 10,
                VulnerabilitySeverity.HIGH: 7,
                VulnerabilitySeverity.MEDIUM: 4,
                VulnerabilitySeverity.LOW: 1
            }

            base_score = severity_weight.get(vuln.severity, 1)

            # Age factor (older = higher risk)
            age_days = (datetime.utcnow() - vuln.detection_date).days
            age_factor = min(age_days / 30, 3)  # Max 3x multiplier

            vuln_score = base_score * (1 + age_factor)
            total_score += vuln_score

        # Normalize to 0-100 scale
        return min(int(total_score), 100)

    def generate_remediation_plan(self, tenant_id: str = "system") -> Dict[str, Any]:
        """Generate prioritized remediation plan"""
        vulnerabilities = [
            vuln for vuln in self.active_vulnerabilities.values()
            if vuln.tenant_id == tenant_id and vuln.status not in [
                VulnerabilityStatus.RESOLVED, VulnerabilityStatus.FALSE_POSITIVE
            ]
        ]

        # Sort by priority (lower number = higher priority)
        sorted_vulns = sorted(vulnerabilities, key=lambda x: x.remediation_priority)

        plan = {
            'tenant_id': tenant_id,
            'generated_at': datetime.utcnow(),
            'total_vulnerabilities': len(vulnerabilities),
            'remediation_plan': []
        }

        for vuln in sorted_vulns:
            plan['remediation_plan'].append({
                'vulnerability_id': vuln.id,
                'title': vuln.title,
                'severity': vuln.severity.value,
                'priority': vuln.remediation_priority,
                'due_date': vuln.due_date.isoformat() if vuln.due_date else None,
                'remediation_steps': vuln.remediation_steps,
                'effort': vuln.remediation_effort,
                'assigned_to': vuln.assigned_to
            })

        return plan

    def check_compliance_status(self, tenant_id: str = "system") -> Dict[str, Any]:
        """Check ISO 27001 vulnerability management compliance"""
        vulnerabilities = [
            vuln for vuln in self.active_vulnerabilities.values()
            if vuln.tenant_id == tenant_id
        ]

        compliance_checks = {
            'regular_scanning': self._check_scanning_frequency(tenant_id),
            'timely_remediation': self._check_remediation_timeliness(vulnerabilities),
            'risk_assessment': self._check_risk_assessment(vulnerabilities),
            'documentation': self._check_documentation_completeness(vulnerabilities)
        }

        overall_compliant = all(check['compliant'] for check in compliance_checks.values())

        return {
            'tenant_id': tenant_id,
            'overall_compliant': overall_compliant,
            'compliance_checks': compliance_checks,
            'iso_control': 'A.12.6.1',
            'last_assessment': datetime.utcnow().isoformat()
        }

    def _check_scanning_frequency(self, tenant_id: str) -> Dict[str, Any]:
        """Check if vulnerability scanning is performed regularly"""
        # In production, check scan history
        last_scan_days = 3  # Mock: 3 days ago
        required_frequency = self.risk_thresholds['scan_frequency_days']

        compliant = last_scan_days <= required_frequency

        return {
            'compliant': compliant,
            'last_scan_days': last_scan_days,
            'required_frequency_days': required_frequency,
            'message': f"Last scan {last_scan_days} days ago (required: ≤{required_frequency})"
        }

    def _check_remediation_timeliness(self, vulnerabilities: List[Vulnerability]) -> Dict[str, Any]:
        """Check if vulnerabilities are remediated within SLA"""
        overdue = 0
        total_active = 0

        for vuln in vulnerabilities:
            if vuln.status not in [VulnerabilityStatus.RESOLVED, VulnerabilityStatus.FALSE_POSITIVE]:
                total_active += 1
                if vuln.due_date and datetime.utcnow() > vuln.due_date:
                    overdue += 1

        compliant = overdue == 0

        return {
            'compliant': compliant,
            'overdue_count': overdue,
            'active_vulnerabilities': total_active,
            'message': f"{overdue} overdue vulnerabilities out of {total_active} active"
        }

    def _check_risk_assessment(self, vulnerabilities: List[Vulnerability]) -> Dict[str, Any]:
        """Check if risk assessment is performed for vulnerabilities"""
        assessed = sum(1 for vuln in vulnerabilities if vuln.evidence)
        total = len(vulnerabilities)

        compliant = assessed == total

        return {
            'compliant': compliant,
            'assessed_count': assessed,
            'total_vulnerabilities': total,
            'message': f"{assessed}/{total} vulnerabilities have risk assessment"
        }

    def _check_documentation_completeness(self, vulnerabilities: List[Vulnerability]) -> Dict[str, Any]:
        """Check if vulnerability documentation is complete"""
        complete_docs = sum(1 for vuln in vulnerabilities
                          if vuln.remediation_steps and vuln.evidence)
        total = len(vulnerabilities)

        compliant = complete_docs == total

        return {
            'compliant': compliant,
            'complete_docs_count': complete_docs,
            'total_vulnerabilities': total,
            'message': f"{complete_docs}/{total} vulnerabilities have complete documentation"
        }